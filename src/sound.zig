/// terminology I'm using in this file
/// --------------------------------------------------------------------------------
/// frequency/freq: the frequency of a sound (i.e. frequency 440 Hz is equivalent to an A4)
/// note: a MIDI note with a name like "A4", "CSharp3" etc
/// tone: a sound generated by a single voice
/// volume: will always be a in integer "percentage" value (i.e. 0 to 100)

const std = @import("std");
const web = @import("web.zig");

pub const Sound = struct {
    song1_bass_player: SongPlayer = .{ .song = song1.bass.ref() },
    song1_wiggler_player: SongPlayer = .{ .song = song1.wiggler.ref() },
    song1_melody_player: SongPlayer = .{ .song = song1.melody.ref() },
    //song1_player: SongPlayer = .{ .song = song1.bass.ref() },
    //song1_player: SongPlayer = .{ .song = song1.combined.ref() },
    pub fn play(self: *Sound, elapsed: u32) void {
        self.song1_bass_player.play(elapsed);
        self.song1_wiggler_player.play(elapsed);
        self.song1_melody_player.play(elapsed);
        //self.song1_player.play(elapsed);
    }
};

const SongPlayer = struct {
    song: SongRef,
    index: usize = 0,
    at: u32 = 0,
    pub fn play(self: *SongPlayer, elapsed: u32) void {
        self.at = self.at +| elapsed;
        while (self.index < self.song.tones.len and self.at >= self.song.tones[self.index].at) {
            const tone = &self.song.tones[self.index];
            web.consoleLog("play tone (index {} freq {}, late by {} ms)!", .{
                self.index, tone.freq, self.at - tone.at});
            web.tone(tone.freq, tone.dur, tone.vol);
            self.index += 1;
        }
        if (self.at >= self.song.dur) {
            self.index = 0;
            self.at = 0;
        }
    }
};

const SongRef = struct {
    /// duration in milliseconds
    dur: u32,
    tones: []const ToneEvent,
};

fn SongValue(comptime tone_count: usize) type {
    return struct {
        const Self = @This();

        /// duration in milliseconds
        dur: u32,
        tones: [tone_count]ToneEvent,
        pub fn ref(self: *const Self) SongRef {
            return .{ .dur = self.dur, .tones = &self.tones };
        }
    };
}


fn countSongsToneEvents(songs: []const SongRef) usize {
    var count: usize = 0;
    for (songs) |song| {
        count += song.tones.len;
    }
    return count;
}

fn getDuration(tones: []const ToneEvent) u32 {
    var max_dur: u32 = 0;
    for (tones) |tone| {
        max_dur = std.math.max(max_dur, tone.at + tone.dur);
    }
    return max_dur;
}

fn CombineSongs(comptime songs: []const SongRef) type {
    //const tone_count = countSongsToneEvents(songs);
    _ = songs;
    const tone_count = 0;
    return struct {
        pub const song: SongValue(tone_count) = blk: {
            break :blk .{ .dur = 0, .tones = &[_]ToneEvent{ } };
//            var tones: [tone_count]ToneEvent = undefined;
//            var tone_indices = [_]usize { 0 } ** songs.len;
//            var new_song_i: usize = 0;
//            while (new_song_i < tone_count) {
//                var next_at = std.math.maxInt(u32);
//                for (songs) |s, i| {
//                    const s_tone_i = tone_indices[i];
//                    const at =
//                        if (s_tone_i == s.tones.len) std.math.maxInt(u32)
//                        else s.tones[s_tone_i].at;
//                    next_at = std.math.min(next_at, at);
//                }
//                std.debug.assert(next_at != std.math.maxInt(u32));
//                const save_new_song_i = new_song_i;
//                for (songs) |s, i| {
//                    const s_tone_i = tone_indices[i];
//                    if (s_tone_i < s.tones.len) {
//                        const tone = &s.tones[s_tone_i];
//                        if (tone.at == next_at) {
//                            tones[new_song_i] = .{
//                            };
//                            new_song_i += 1;
//                        }
//                    }
//                }
//                std.debug.assert(new_song_i > save_new_song_i);
//            }
//            for (tone_indices) |tone_index, i| {
//                std.debug.assert(tone_index == songs[i].tones.len);
//            }
//            break :blk .{ .dur = getDuration(tones), .tones = tones };
        };
    };
}

const song1 = struct {
    const bass = Solo(&[_]SoloNode{
        .{ .ms_per_beat = 150 },
        .{ .vol = 8 },
        // INTRO
        .{ .abs_tone = .{ .note = .c2 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .g2 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .d3 , .beats = 4 } },
        .{ .abs_tone = .{ .note = .e3 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .d3 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .c3 , .beats = 2 } },
        //
        .{ .abs_tone = .{ .note = .c2 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .g2 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .d3 , .beats = 4 } },
        .{ .abs_tone = .{ .note = .e3 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .g3 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .d3 , .beats = 2 } },
        // VERSE1
        .{ .abs_tone = .{ .note = .c2 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .g2 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .d3 , .beats = 4 } },
        .{ .abs_tone = .{ .note = .e3 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .d3 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .c3 , .beats = 2 } },
        //
        .{ .abs_tone = .{ .note = .c2 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .g2 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .d3 , .beats = 4 } },
        .{ .abs_tone = .{ .note = .c2 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .g2 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .e2 , .beats = 2 } },
        //
        .{ .abs_tone = .{ .note = .f1 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .c2 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .g2 , .beats = 4 } },
        .{ .abs_tone = .{ .note = .a2 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .g2 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .f2 , .beats = 2 } },
        //
        .{ .abs_tone = .{ .note = .f1 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .c2 , .beats = 3 } },
        .{ .abs_tone = .{ .note = .g2 , .beats = 4 } },
        .{ .abs_tone = .{ .note = .a2 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .g2 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .f2 , .beats = 2 } },
    }).song;
    const wiggler = Solo(&[_]SoloNode{
        .{ .ms_per_beat = 150 },
        .{ .vol = 3 },
        .{ .abs_tone = .{ .note = .c6 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .b5 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .g5 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .e5 , .beats = 1 } },
    }).song;
    const melody = Solo(&[_]SoloNode{
        .{ .ms_per_beat = 150 },
        .{ .vol = 12 },
        .{ .rest = 32 },
        .{ .abs_tone = .{ .note = .e4 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .f4 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .e4 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .g4 , .beats = 9 } },
        .{ .rest = 1 },
        .{ .abs_tone = .{ .note = .a4 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .g4 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .e4 , .beats = 8 } },
        .{ .rest = 2 },
        .{ .abs_tone = .{ .note = .c4 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .e4 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .g4 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .c5 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .b4 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .g4 , .beats = 1 } },
        .{ .abs_tone = .{ .note = .e4 , .beats = 1 } },
        //
        .{ .abs_tone = .{ .note = .d4 , .beats = 6 } },
        .{ .abs_tone = .{ .note = .c4 , .beats = 6 } },
        .{ .rest = 14 },
        .{ .abs_tone = .{ .note = .c4 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .d4 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .c4 , .beats = 2 } },
        .{ .abs_tone = .{ .note = .d4 , .beats = 6 } },
        .{ .abs_tone = .{ .note = .e4 , .beats = 8 } },
        .{ .rest = 16 },
    }).song;
    pub const combined = CombineSongs(&[_]SongRef{
        bass.ref(),
    });
};

pub const ToneEvent = struct {
    at: u32,
    freq: f32,
    dur: u32,
    vol: u8,
};

fn countSoloToneEvents(solo: []const SoloNode) usize {
    var count: usize = 0;
    for (solo) |note| switch (note) {
        .ms_per_beat => {},
        .vol => {},
        .rest => {},
        .abs_tone => {
            count += 1;
        },
    };
    return count;
}

const SoloNode = union(enum) {
    ms_per_beat: u32,
    vol: u8,
    rest: u32,
    abs_tone: struct {
        note: Note,
        beats: u32,
    },
    // todo: relative note
    //       note is relative to the last abs_tone played
};

const SoloState = struct {
    ms: u32 = 0,
    vol: u8 = 100,
    ms_per_beat: ?u32 = null,

    pub fn requireMsPerBeat(self: @This()) u32 {
        return self.ms_per_beat orelse @panic("solo must set ms_per_beat before this");
    }
};

fn Solo(comptime solo_nodes: []const SoloNode) type {
    const tone_count = countSoloToneEvents(solo_nodes);
    return struct {
        pub const song: SongValue(tone_count) = blk: {
            var tones: [tone_count]ToneEvent = undefined;
            var tone_index: usize = 0;
            var state = SoloState{ };
            for (solo_nodes) |node| switch (node) {
                .ms_per_beat => |ms_per_beat| {
                    state.ms_per_beat = ms_per_beat;
                },
                .vol => |vol| {
                    state.vol = vol;
                },
                .rest => |beats| {
                    state.ms += beats * state.requireMsPerBeat();
                },
                .abs_tone => |tone| {
                    const dur = tone.beats * state.requireMsPerBeat();
                    tones[tone_index] = .{
                        .at = state.ms,
                        .freq = tone.note.freq(),
                        .dur = dur,
                        .vol = state.vol,
                    };
                    tone_index += 1;
                    state.ms += dur;
                },
            };
            std.debug.assert(tone_index == tone_count);
            break :blk .{ .dur = state.ms, .tones = tones };
        };
    };
}

/// used for converting midi notes to frequencies
const twelvth_root_of_2 = std.math.pow(f32, 2, 1.0/12.0);

const Note = enum(u7) {
    cneg1  =  0,
    csneg1 =  1,
    dneg1  =  2,
    dsneg1 =  3,
    eneg1  =  4,
    fneg1  =  5,
    fsneg1 =  6,
    gneg1  =  7,
    gsneg1 =  8,
    aneg1  =  9,
    asneg1 = 10,
    bneg1  = 11,
    c0  =  12,
    cs0 =  13,
    d0  =  14,
    ds0 =  15,
    e0  =  16,
    f0  =  17,
    fs0 =  18,
    g0  =  19,
    gs0 =  20,
    a0  =  21,
    as0 =  22,
    b0  =  23,
    c1  =  24,
    cs1 =  25,
    d1  =  26,
    ds1 =  27,
    e1  =  28,
    f1  =  29,
    fs1 =  30,
    g1  =  31,
    gs1 =  32,
    a1  =  33,
    as1 =  34,
    b1  =  35,
    c2  =  36,
    cs2 =  37,
    d2  =  38,
    ds2 =  39,
    e2  =  40,
    f2  =  41,
    fs2 =  42,
    g2  =  43,
    gs2 =  44,
    a2  =  45,
    as2 =  46,
    b2  =  47,
    c3  =  48,
    cs3 =  49,
    d3  =  50,
    ds3 =  51,
    e3  =  52,
    f3  =  53,
    fs3 =  54,
    g3  =  55,
    gs3 =  56,
    a3  =  57,
    as3 =  58,
    b3  =  59,
    c4  =  60,
    cs4 =  61,
    d4  =  62,
    ds4 =  63,
    e4  =  64,
    f4  =  65,
    fs4 =  66,
    g4  =  67,
    gs4 =  68,
    a4  =  69,
    as4 =  70,
    b4  =  71,
    c5  =  72,
    cs5 =  73,
    d5  =  74,
    ds5 =  75,
    e5  =  76,
    f5  =  77,
    fs5 =  78,
    g5  =  79,
    gs5 =  80,
    a5  =  81,
    as5 =  82,
    b5  =  83,
    c6  =  84,
    cs6 =  85,
    d6  =  86,
    ds6 =  87,
    e6  =  88,
    f6  =  89,
    fs6 =  90,
    g6  =  91,
    gs6 =  92,
    a6  =  93,
    as6 =  94,
    b6  =  95,
    c7  =  96,
    cs7 =  97,
    d7  =  98,
    ds7 =  99,
    e7  = 100,
    f7  = 101,
    fs7 = 102,
    g7  = 103,
    gs7 = 104,
    a7  = 105,
    as7 = 106,
    b7  = 107,
    c8  = 108,
    cs8 = 109,
    d8  = 110,
    ds8 = 111,
    e8  = 112,
    f8  = 113,
    fs8 = 114,
    g8  = 115,
    gs8 = 116,
    a8  = 117,
    as8 = 118,
    b8  = 119,
    c9  = 120,
    cs9 = 121,
    d9  = 122,
    ds9 = 123,
    e9  = 124,
    f9  = 125,
    fs9 = 126,
    g9  = 127,
    pub fn freq(self: Note) f32 {
        const exp = @intCast(i32, @enumToInt(self)) - 69;
        return 440.0 * std.math.pow(f32, twelvth_root_of_2, @intToFloat(f32, exp));
    }
};
